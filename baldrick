#!/usr/bin/env bash
set -eo pipefail

# baldrick - AI-assisted feature execution for Claude Code
# "I have a cunning plan!" - Baldrick, Blackadder
#
# Unified tool for spec creation and execution.
#
# Prerequisites:
#   - Claude Code CLI installed and authenticated
#   - Run /sandbox in Claude Code first for bash auto-allow

VERSION="1.3.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# =============================================================================
# CONFIGURATION (can be overridden for testing)
# =============================================================================

: "${PROJECT_DIR:=$PWD}"
: "${SPECS_DIR:=$PROJECT_DIR/specs}"
: "${DOCS_DIR:=$PROJECT_DIR/docs}"
: "${TEMPLATES_DIR:=$SCRIPT_DIR/templates}"
: "${PROGRESS_FILE:=$PROJECT_DIR/progress.txt}"
: "${LEARNINGS_FILE:=$PROJECT_DIR/baldrick-learnings.md}"
: "${LOG_DIR:=$PROJECT_DIR/logs}"
: "${ARCHIVE_DIR:=$PROJECT_DIR/archive}"
: "${LAST_SESSION_FILE:=$PROJECT_DIR/.last-session}"

# Build/test/lint commands - configure for your project
: "${BUILD_CMD:=npm run build}"
: "${TEST_CMD:=npm test}"
: "${LINT_CMD:=npm run lint}"

# Quality tier: prototype | production | library
: "${QUALITY_TIER:=production}"

# Reviewer cadence: run reviewer mode every N iterations
: "${REVIEW_EVERY:=5}"

# Notification command (optional)
: "${NOTIFY_CMD:=}"

# Claude runner - injectable for testing
: "${CLAUDE_RUNNER:=claude}"

# Timeout for Claude sessions (prevents hung loops)
: "${CLAUDE_TIMEOUT:=300}"  # 5 minutes default

# Activity logging
: "${ACTIVITY_LOG:=$LOG_DIR/activity.log}"

# =============================================================================
# EMBEDDED AGENT INSTRUCTIONS (no external baldrick-prompt.md needed)
# =============================================================================

# Note: read returns 1 at EOF even on success, so we use || true
read -r -d '' EMBEDDED_PROMPT << 'PROMPT_EOF' || true
# Baldrick Agent Instructions

You are an autonomous coding agent working through feature specifications.

## Your Task

The core loop has **deterministically selected** the highest priority spec for you.
Look for `## SELECTED SPEC` in the context - implement that one.

1. Read `## Codebase Patterns` at TOP of `progress.txt` FIRST
2. Read `baldrick-learnings.md` for permanent patterns
3. Find the **SELECTED SPEC** section in the context (this is your target)
4. Implement that single spec following BDD scenarios
5. Run quality checks (see Configuration section below)
6. If checks pass, commit ALL changes
7. Update the spec to set `passes: true`
8. Append progress to `progress.txt`

**Important:** Do NOT pick a different spec. The core loop has already selected the correct one based on priority and dependency ordering.

## Quality Requirements

**CRITICAL**: ALL commits must pass quality checks.
Run the build, test, and lint commands from the Configuration section.
Do NOT set `passes: true` until ALL checks pass.
PASTE the actual command output in your progress notes.

## Progress Report Format

APPEND to progress.txt (never replace, always append):

```
## [Date/Time] - [Spec Name]
Session: [see Configuration section]
- What: What was implemented
- Test output: (paste actual command output)
- Learnings: Patterns discovered, gotchas encountered
---
```

The learnings section is critical - it helps future iterations avoid repeating mistakes.

## Consolidate Patterns

If you discover a **reusable pattern**, add it to BOTH:
1. `## Codebase Patterns` section at TOP of progress.txt
2. `baldrick-learnings.md` (permanent storage)

Only add patterns that are **general and reusable**, not spec-specific details.

## Log Tradeoffs

When you make a significant decision, APPEND to `tradeoffs.md`:

```
## [Date] - [Decision Title]
Spec: [spec name]
Decision: [what you chose]
Alternatives: [what you considered]
Rationale: [why you chose this]
---
```

**You MUST log a tradeoff when you:**
- Change or introduce a data model / schema
- Make a security or auth decision
- Choose between architectural approaches
- Introduce a new dependency
- Change a public API contract

Create `tradeoffs.md` if it doesn't exist. This file answers "why was it done this way?" for future maintainers.

## Commit Message Format

Use conventional commits:
```
feat: [Spec Name] - Brief description

- Key change 1
- Key change 2
```

## Stop Condition

After completing a spec, check if ALL specs have `passes: true`.

If ALL specs are complete and passing:
1. `touch .baldrick-done`
2. Output: `<promise>COMPLETE</promise>`

If there are still specs with `passes: false`, end normally (another iteration will pick up the next spec).

## Stuck Detection

If you cannot make progress:
- Try a DIFFERENT approach
- Add debugging to understand the issue
- Read errors carefully, fix root cause

If truly blocked after multiple attempts:
- Output: `<promise>BLOCKED</promise>` with explanation

## Important Rules

- Work on **ONE spec per iteration**
- Commit frequently
- Keep all checks passing
- Read Codebase Patterns FIRST before implementing
- Follow existing code patterns in the codebase
PROMPT_EOF

# =============================================================================
# PROJECT TYPE AUTO-DETECTION
# =============================================================================

# Track detected project type for doctor output
DETECTED_PROJECT_TYPE="npm (default)"

detect_project_type() {
  # Only auto-detect if using default npm commands and no package.json exists
  # This preserves user's explicit settings while helping non-npm projects
  if [[ "$BUILD_CMD" == "npm run build" ]] && [[ ! -f "package.json" ]]; then
    if [[ -f "Makefile" ]]; then
      DETECTED_PROJECT_TYPE="make"
      BUILD_CMD="make build 2>/dev/null || make"
      TEST_CMD="make test 2>/dev/null || true"
      LINT_CMD="make lint 2>/dev/null || true"
    elif [[ -f "go.mod" ]]; then
      DETECTED_PROJECT_TYPE="go"
      BUILD_CMD="go build ./..."
      TEST_CMD="go test ./..."
      LINT_CMD="go vet ./..."
    elif [[ -f "Cargo.toml" ]]; then
      DETECTED_PROJECT_TYPE="rust"
      BUILD_CMD="cargo build"
      TEST_CMD="cargo test"
      LINT_CMD="cargo clippy 2>/dev/null || true"
    elif [[ -f "pyproject.toml" ]] || [[ -f "setup.py" ]] || [[ -f "requirements.txt" ]]; then
      DETECTED_PROJECT_TYPE="python"
      BUILD_CMD="python -m py_compile *.py 2>/dev/null || true"
      TEST_CMD="pytest 2>/dev/null || python -m pytest 2>/dev/null || true"
      LINT_CMD="ruff check . 2>/dev/null || flake8 2>/dev/null || true"
    elif [[ -f "mix.exs" ]]; then
      DETECTED_PROJECT_TYPE="elixir"
      BUILD_CMD="mix compile"
      TEST_CMD="mix test"
      LINT_CMD="mix credo 2>/dev/null || true"
    else
      DETECTED_PROJECT_TYPE="none (no build system detected)"
      BUILD_CMD="true"  # No-op
      TEST_CMD="true"
      LINT_CMD="true"
    fi
  elif [[ -f "package.json" ]]; then
    DETECTED_PROJECT_TYPE="npm"
  fi
}

# =============================================================================
# COLORS (testable: can be disabled with NO_COLOR=1)
# =============================================================================

if [[ -z "${NO_COLOR:-}" && -t 1 ]]; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  CYAN='\033[0;36m'
  BOLD='\033[1m'
  DIM='\033[2m'
  NC='\033[0m'
else
  RED='' GREEN='' YELLOW='' BLUE='' CYAN='' BOLD='' DIM='' NC=''
fi

# =============================================================================
# SPINNER (isolated for testing)
# =============================================================================

SPINNER_PID=""
SPINNER_START=""

start_spinner() {
  local msg="${1:-Working}"
  SPINNER_START=$(date +%s)
  (
    local chars="â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
    local i=0
    while true; do
      local elapsed=$(( $(date +%s) - SPINNER_START ))
      local mins=$((elapsed / 60))
      local secs=$((elapsed % 60))
      printf "\r\033[K%s %s [%02d:%02d]" "${chars:i%10:1}" "$msg" "$mins" "$secs"
      sleep 0.1
      ((i++))
    done
  ) &
  SPINNER_PID=$!
  disown $SPINNER_PID 2>/dev/null
}

stop_spinner() {
  if [[ -n "$SPINNER_PID" ]]; then
    kill $SPINNER_PID 2>/dev/null
    wait $SPINNER_PID 2>/dev/null || true
    SPINNER_PID=""
    printf "\r\033[K"
  fi
}

# =============================================================================
# ACTIVITY LOGGING (audit trail)
# =============================================================================

# Log timestamped activity to audit trail
log_activity() {
  mkdir -p "$(dirname "$ACTIVITY_LOG")"
  echo "$(date '+%Y-%m-%d %H:%M:%S') | $1" >> "$ACTIVITY_LOG"
}


# =============================================================================
# PURE UTILITY FUNCTIONS (no side effects, testable in isolation)
# =============================================================================

# Extract YAML frontmatter field from a file
extract_field() {
  local file="$1" field="$2"
  sed -n '/^---$/,/^---$/p' "$file" 2>/dev/null | \
    grep "^${field}:" 2>/dev/null | head -1 | sed "s/^${field}:[[:space:]]*//" || true
}

# Check if spec passes
spec_passes() {
  [[ "$(extract_field "$1" "passes")" == "true" ]]
}

# Get priority from spec (defaults to medium)
get_priority() {
  local p
  p=$(extract_field "$1" "priority")
  echo "${p:-medium}"
}

# Get risk from spec (defaults to standard)
get_risk() {
  local r
  r=$(extract_field "$1" "risk")
  echo "${r:-standard}"
}

# Priority to numeric order for sorting
priority_order() {
  case "$1" in
    high) echo 1 ;; medium) echo 2 ;; low) echo 3 ;; *) echo 2 ;;
  esac
}

# Risk to numeric order for sorting
risk_order() {
  case "$1" in
    spike) echo 1 ;; integration) echo 2 ;; standard) echo 3 ;; polish) echo 4 ;; *) echo 3 ;;
  esac
}

# Find spec file by id field
find_spec_by_id() {
  local target_id="$1"
  for spec in "$SPECS_DIR"/*.md; do
    [[ -f "$spec" ]] || continue
    local spec_id
    spec_id=$(extract_field "$spec" "id")
    if [[ "$spec_id" == "$target_id" ]]; then
      echo "$spec"
      return 0
    fi
  done
  return 1
}

# Check if spec dependencies are satisfied
# depends_on is an array of spec ids (not filenames)
check_dependencies() {
  local spec="$1"
  local depends_on
  depends_on=$(extract_field "$spec" "depends_on")

  [[ -z "$depends_on" ]] && return 0  # No dependencies

  # Clean up YAML array syntax: remove brackets, quotes, split by comma
  depends_on="${depends_on#[}"
  depends_on="${depends_on%]}"
  depends_on="${depends_on//\"/}"
  depends_on="${depends_on//\'/}"

  # Split by comma and/or whitespace, check each dependency id
  local dep_id dep_file
  for dep_id in ${depends_on//,/ }; do
    dep_id="${dep_id// /}"      # Trim whitespace
    [[ -z "$dep_id" ]] && continue

    # Find spec by id field
    dep_file=$(find_spec_by_id "$dep_id")
    if [[ -z "$dep_file" ]]; then
      return 1  # Dependency id not found
    fi
    if ! spec_passes "$dep_file"; then
      return 1  # Dependency not complete
    fi
  done

  return 0
}

# Get created date from spec (for sorting)
get_created() {
  local c
  c=$(extract_field "$1" "created")
  echo "${c:-9999-99-99}"  # Default to far future if not set
}

# Get id from spec (for sorting)
get_id() {
  local id
  id=$(extract_field "$1" "id")
  echo "${id:-zzz}"  # Default to end of alphabet if not set
}

# Get the next spec to work on (deterministic selection)
# Selection: priority (highâ†’low) â†’ risk (spikeâ†’polish) â†’ created (oldâ†’new) â†’ id (Aâ†’Z)
get_next_spec() {
  local candidates=()

  for spec in "$SPECS_DIR"/*.md; do
    [[ -f "$spec" ]] || continue
    [[ "$(basename "$spec")" == _* ]] && continue

    # Skip completed specs (passes = true)
    spec_passes "$spec" && continue

    # Skip specs with blocked_by set
    local blocked_by
    blocked_by=$(extract_field "$spec" "blocked_by")
    [[ -n "$blocked_by" ]] && continue

    # Skip specs with unmet dependencies
    if ! check_dependencies "$spec"; then
      continue
    fi

    candidates+=("$spec")
  done

  # No candidates
  [[ ${#candidates[@]} -eq 0 ]] && return

  # Sort candidates: priority (highâ†’low) â†’ risk (spikeâ†’polish) â†’ created (oldâ†’new) â†’ id (Aâ†’Z)
  local best_spec=""
  local best_p=999 best_r=999 best_c="9999-99-99" best_id="zzz"

  for spec in "${candidates[@]}"; do
    local p_order r_order created spec_id
    p_order=$(priority_order "$(get_priority "$spec")")
    r_order=$(risk_order "$(get_risk "$spec")")
    created=$(get_created "$spec")
    spec_id=$(get_id "$spec")

    # Compare: priority â†’ risk â†’ created â†’ id
    local dominated=false
    if [[ $p_order -lt $best_p ]]; then
      dominated=false
    elif [[ $p_order -gt $best_p ]]; then
      dominated=true
    elif [[ $r_order -lt $best_r ]]; then
      dominated=false
    elif [[ $r_order -gt $best_r ]]; then
      dominated=true
    elif [[ "$created" < "$best_c" ]]; then
      dominated=false
    elif [[ "$created" > "$best_c" ]]; then
      dominated=true
    elif [[ "$spec_id" < "$best_id" ]]; then
      dominated=false
    else
      dominated=true
    fi

    if [[ "$dominated" == "false" ]]; then
      best_spec="$spec"
      best_p=$p_order
      best_r=$r_order
      best_c="$created"
      best_id="$spec_id"
    fi
  done

  echo "$best_spec"
}

# Get quality instructions based on tier
get_quality_instructions() {
  local tier="${1:-$QUALITY_TIER}"
  case "$tier" in
    prototype)
      echo "## Quality: PROTOTYPE
Speed over perfection. Skip edge cases. Minimal tests. Get it working first."
      ;;
    library)
      echo "## Quality: LIBRARY
Public API stability matters. Maintain backward compatibility. Document all public interfaces."
      ;;
    *)
      echo "## Quality: PRODUCTION
Maintainable code. Full test coverage. Handle errors properly. No shortcuts."
      ;;
  esac
}

# =============================================================================
# SESSION TRACKING
# =============================================================================

SESSION_ID=""

generate_session_id() {
  SESSION_ID="baldrick-$(date +%Y%m%d%H%M%S)-$$"
}

get_current_session() {
  if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    local branch
    branch=$(git branch --show-current 2>/dev/null)
    if [[ "$branch" == baldrick/* ]]; then
      echo "$branch"
      return
    fi
  fi
  if [[ -d "$SPECS_DIR" ]]; then
    local first_spec
    first_spec=$(ls -1 "$SPECS_DIR"/*.md 2>/dev/null | head -1)
    if [[ -n "$first_spec" ]]; then
      echo "specs/$(basename "$first_spec" .md)"
      return
    fi
  fi
  echo ""
}

archive_session() {
  local session_name="$1"
  [[ -z "$session_name" ]] && return 1

  local DATE FOLDER_NAME ARCHIVE_FOLDER
  DATE=$(date +%Y-%m-%d)
  FOLDER_NAME=$(echo "$session_name" | sed 's|^baldrick/||' | sed 's|^specs/||')
  ARCHIVE_FOLDER="$ARCHIVE_DIR/$DATE-$FOLDER_NAME"

  echo -e "${CYAN}Archiving: $session_name${NC}"
  mkdir -p "$ARCHIVE_FOLDER"

  if [[ -d "$SPECS_DIR" ]] && [[ -n "$(ls -A "$SPECS_DIR"/*.md 2>/dev/null)" ]]; then
    mkdir -p "$ARCHIVE_FOLDER/specs"
    cp "$SPECS_DIR"/*.md "$ARCHIVE_FOLDER/specs/" 2>/dev/null || true
  fi
  [[ -f "$PROGRESS_FILE" ]] && cp "$PROGRESS_FILE" "$ARCHIVE_FOLDER/"
  [[ -f "$LEARNINGS_FILE" ]] && cp "$LEARNINGS_FILE" "$ARCHIVE_FOLDER/"
  if [[ -d "$LOG_DIR" ]] && [[ -n "$(ls -A "$LOG_DIR" 2>/dev/null)" ]]; then
    mkdir -p "$ARCHIVE_FOLDER/logs"
    cp "$LOG_DIR"/*.log "$ARCHIVE_FOLDER/logs/" 2>/dev/null || true
  fi

  echo -e "${GREEN}  â†’ $ARCHIVE_FOLDER${NC}"
}

check_session_change() {
  local current
  current=$(get_current_session)
  [[ -z "$current" ]] && return 0

  if [[ -f "$LAST_SESSION_FILE" ]]; then
    local last
    last=$(cat "$LAST_SESSION_FILE" 2>/dev/null || echo "")
    if [[ -n "$last" ]] && [[ "$current" != "$last" ]]; then
      echo -e "${YELLOW}Session change:${NC} $last â†’ $current"
      archive_session "$last"
      cat > "$PROGRESS_FILE" <<EOF
# Baldrick Progress Log

## Codebase Patterns
<!-- Consolidated reusable patterns - READ THIS FIRST -->

## Key Files
<!-- Critical files for this project -->

---

## Session: $current
Started: $(date)

<!-- Claude appends progress notes below this line -->
EOF
      rm -f "$LOG_DIR"/*.log 2>/dev/null || true
    fi
  fi
  echo "$current" > "$LAST_SESSION_FILE"
}

notify_completion() {
  local status="$1" iterations="$2" elapsed="$3"
  if [[ -n "$NOTIFY_CMD" ]]; then
    local msg="baldrick ${status}: ${iterations} iterations in ${elapsed}"
    eval "$NOTIFY_CMD \"$msg\"" 2>/dev/null || true
  fi
}

# =============================================================================
# CLAUDE INTERFACE (injectable for testing)
# =============================================================================

CLAUDE_RESULT=""
CLAUDE_EXIT=0

run_claude() {
  local prompt="$1" log_file="$2" verbose="${3:-false}"
  local temp exit_code
  temp=$(mktemp)

  if [[ "$verbose" == "true" ]]; then
    # Verbose mode: stream output in real-time
    echo -e "${CYAN}â”€â”€â”€ Claude output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    timeout "$CLAUDE_TIMEOUT" $CLAUDE_RUNNER --permission-mode acceptEdits -p "$prompt" 2>&1 | tee "$temp"
    exit_code=${PIPESTATUS[0]}
    echo -e "${CYAN}â”€â”€â”€ End output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  else
    # Normal mode: spinner with silent execution
    start_spinner "Claude is working..."
    timeout "$CLAUDE_TIMEOUT" $CLAUDE_RUNNER --permission-mode acceptEdits -p "$prompt" 2>&1 > "$temp"
    exit_code=$?
    stop_spinner
  fi

  # Handle timeout (exit code 124)
  if [[ $exit_code -eq 124 ]]; then
    echo -e "${RED}âœ—${NC} Claude timed out after ${CLAUDE_TIMEOUT}s"
  fi

  local lines
  lines=$(wc -l < "$temp" | tr -d ' ')
  [[ "$verbose" != "true" ]] && echo -e "${GREEN}âœ“${NC} Claude responded ($lines lines)"

  [[ -n "$log_file" ]] && cat "$temp" >> "$log_file"
  CLAUDE_RESULT=$(cat "$temp")
  CLAUDE_EXIT=$exit_code

  rm -f "$temp"
  return $exit_code
}

# =============================================================================
# COMMAND: help
# =============================================================================

cmd_help() {
  cat <<EOF
${BOLD}baldrick v$VERSION${NC} - AI-assisted feature execution

${CYAN}Usage:${NC} baldrick <command> [options]

${CYAN}Execution:${NC}
  run [n] [--dry-run]     Run n iterations (default: 10)
  once <spec> [--max n]   Focus on single spec until done

${CYAN}Status:${NC}
  status                  Show specs and progress
  validate                Check specs for errors

${CYAN}Utilities:${NC}
  init                    Setup templates and directories
  new <name>              Create new spec interactively
  archive [list|restore]  Manage session archives
  doctor                  Check configuration and dependencies
  logs [show|tail|list]   View iteration logs
  skip <spec>             Temporarily skip a spec
  unskip <spec>           Re-enable a skipped spec
  help                    Show this help

${CYAN}Aliases:${NC}
  s â†’ status    r â†’ run    v â†’ validate    n â†’ new    l â†’ logs

${CYAN}Configuration (env vars):${NC}
  BUILD_CMD       Build command (default: npm run build)
  TEST_CMD        Test command (default: npm test)
  LINT_CMD        Lint command (default: npm run lint)
  QUALITY_TIER    prototype | production | library
  REVIEW_EVERY    Reviewer mode cadence (default: 5)
  CLAUDE_TIMEOUT  Max seconds per Claude call (default: 300)

${CYAN}Spec Creation (use Claude Code skills):${NC}
  Load "spec-create" skill for interactive creation
  Load "spec-vibe" skill for fast creation (no questions)
  Load "spec-detailed" skill for comprehensive specs
  Load "pr-docs" skill for PR documentation
  Load "coverage-loop" skill for coverage-focused work
  Load "lint-loop" skill for lint-fix work
  Load "entropy-loop" skill for cleanup work

${CYAN}Examples:${NC}
  baldrick run 10
  baldrick once login --max 20
  baldrick status
EOF
}

# =============================================================================
# COMMAND: status
# =============================================================================

cmd_status() {
  if [[ ! -d "$SPECS_DIR" ]] || [[ -z "$(ls -A "$SPECS_DIR"/*.md 2>/dev/null)" ]]; then
    echo "No specs found in $SPECS_DIR"
    echo ""
    echo "Create specs with: baldrick create <name>"
    exit 0
  fi

  echo ""
  echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
  echo -e "${BOLD}â•‘                     Baldrick Status                         â•‘${NC}"
  echo -e "${BOLD}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${NC}"
  printf "â•‘ %-3s â”‚ %-8s â”‚ %-11s â”‚ %-28s â•‘\n" "" "Priority" "Risk" "Spec"
  echo "â• â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£"

  local total=0 complete=0 blocked_count=0

  # Determine next spec for highlighting
  local next_spec_name=""
  local next_spec
  next_spec=$(get_next_spec)
  [[ -n "$next_spec" ]] && next_spec_name=$(basename "$next_spec" .md)

  # Generate spec list with status
  # Temporarily disable errexit for this section (fixes set -e + pipe interaction)
  set +e
  {
    for spec in "$SPECS_DIR"/*.md; do
      [[ -f "$spec" ]] || continue
      [[ "$(basename "$spec")" == _* ]] && continue

      local name priority risk p_order r_order status blocked_by
      name=$(basename "$spec" .md)
      priority=$(get_priority "$spec")
      risk=$(get_risk "$spec")
      p_order=$(priority_order "$priority")
      r_order=$(risk_order "$risk")

      # Determine status: done > blocked > pending
      if spec_passes "$spec"; then
        status="done"
      else
        blocked_by=$(extract_field "$spec" "blocked_by")
        if [[ -n "$blocked_by" ]]; then
          status="blocked"
        elif check_dependencies "$spec"; then
          status="pending"
        else
          status="blocked"
        fi
      fi

      echo "${p_order}${r_order}|${status}|${priority}|${risk}|${name}"
    done
  } | sort | NEXT_SPEC="$next_spec_name" bash -c '
    while IFS="|" read -r _ status priority risk name; do
      [[ -z "$name" ]] && continue

      # Colors (simplified in subshell)
      RED="\033[0;31m"; GREEN="\033[0;32m"; YELLOW="\033[1;33m"
      CYAN="\033[0;36m"; DIM="\033[2m"; NC="\033[0m"

      emoji="${YELLOW}â­•${NC}"
      dim=""
      case "$status" in
        done)    emoji="${GREEN}âœ“${NC}"; dim="${DIM}" ;;
        blocked) emoji="${RED}ğŸš«${NC}"; dim="${DIM}" ;;
        pending) emoji="${YELLOW}â­•${NC}" ;;
      esac

      pc="" rc=""
      case "$priority" in
        high) pc="${RED}" ;; medium) pc="${YELLOW}" ;; low) pc="${DIM}" ;;
      esac
      case "$risk" in
        spike) rc="${RED}" ;; integration) rc="${YELLOW}" ;; polish) rc="${DIM}" ;;
      esac

      # Next spec indicator
      next_marker=" "
      if [[ "$name" == "$NEXT_SPEC" ]]; then
        next_marker="${CYAN}â†’${NC}"
      fi

      [[ ${#name} -gt 28 ]] && name="${name:0:25}..."
      printf "â•‘%b %b â”‚ %b%-8s%b â”‚ %b%-11s%b â”‚ %b%-28s%b â•‘\n" \
        "$next_marker" "$emoji" "$pc" "$priority" "$NC" "$rc" "$risk" "$NC" "$dim" "$name" "$NC"
    done
  '
  set -e  # Re-enable errexit

  echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

  # Count stats (temporarily disable errexit for check_dependencies)
  set +e
  for spec in "$SPECS_DIR"/*.md; do
    [[ -f "$spec" ]] || continue
    [[ "$(basename "$spec")" == _* ]] && continue
    ((total++))
    if spec_passes "$spec"; then
      ((complete++))
    else
      local blocked_by
      blocked_by=$(extract_field "$spec" "blocked_by")
      if [[ -n "$blocked_by" ]] || ! check_dependencies "$spec"; then
        ((blocked_count++))
      fi
    fi
  done
  set -e

  echo ""
  local pct=0
  [[ $total -gt 0 ]] && pct=$((complete * 100 / total))
  echo -e "Progress: ${GREEN}$complete${NC}/$total (${pct}%)"
  [[ $blocked_count -gt 0 ]] && echo -e "Blocked: ${RED}$blocked_count${NC} spec(s)"
  [[ -n "$next_spec_name" ]] && echo -e "Next: ${CYAN}$next_spec_name${NC}"
  echo -e "Quality: ${CYAN}$QUALITY_TIER${NC}"
}

# =============================================================================
# COMMAND: run
# =============================================================================

cmd_run() {
  local iterations="" DRY_RUN=false VERBOSE=false

  while [[ $# -gt 0 ]]; do
    case $1 in
      --dry-run) DRY_RUN=true; shift ;;
      --verbose|-v) VERBOSE=true; shift ;;
      -h|--help) echo "Usage: baldrick run [n] [--dry-run] [--verbose|-v]"; exit 0 ;;
      *)
        if [[ "$1" =~ ^[0-9]+$ ]]; then iterations="$1"
        else echo -e "${RED}Invalid:${NC} $1"; exit 1
        fi
        shift ;;
    esac
  done

  iterations="${iterations:-10}"

  if [[ ! -d "$SPECS_DIR" ]] || [[ -z "$(ls -A "$SPECS_DIR"/*.md 2>/dev/null)" ]]; then
    echo -e "${RED}No specs found.${NC}"
    echo "Create specs using a spec skill (spec-create, spec-vibe, etc.)"
    exit 1
  fi

  # Pre-run validation
  if ! cmd_validate --quiet; then
    echo -e "${RED}Spec validation failed.${NC}"
    echo "Run 'baldrick validate' for details."
    exit 1
  fi

  check_session_change
  generate_session_id

  local LOG_FILE="$LOG_DIR/baldrick-$(date '+%Y%m%d-%H%M%S').log"
  local DONE_FILE=".baldrick-done"
  local PROMPT_FILE="/tmp/baldrick-prompt-$$.md"
  mkdir -p "$LOG_DIR"
  rm -f "$DONE_FILE"

  # Write embedded prompt to temp file (cleaned up on exit)
  echo "$EMBEDDED_PROMPT" > "$PROMPT_FILE"
  trap "rm -f '$PROMPT_FILE'" EXIT

  local START_TIME COMPLETED=0 LAST_HASH="" STUCK=0
  START_TIME=$(date +%s)

  get_state_hash() {
    cat "$SPECS_DIR"/*.md 2>/dev/null | md5sum 2>/dev/null | cut -d' ' -f1 || \
    cat "$SPECS_DIR"/*.md 2>/dev/null | md5 -q 2>/dev/null
  }

  show_summary() {
    local end elapsed elapsed_str
    end=$(date +%s)
    elapsed=$((end - START_TIME))
    elapsed_str="$((elapsed / 60))m $((elapsed % 60))s"
    echo ""
    echo -e "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "Iterations: ${GREEN}$COMPLETED${NC}  Time: ${CYAN}$elapsed_str${NC}"
    echo -e "Log: ${DIM}$LOG_FILE${NC}"
    echo -e "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    notify_completion "complete" "$COMPLETED" "$elapsed_str"
  }

  trap 'stop_spinner; echo ""; echo -e "${YELLOW}Interrupted${NC}"; log_activity "Interrupted after $COMPLETED iterations"; rm -f "$DONE_FILE"; show_summary; exit 130' INT

  echo ""
  echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
  echo -e "${BOLD}â•‘          baldrick run                  â•‘${NC}"
  echo -e "${BOLD}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${NC}"
  echo -e "â•‘ Iterations: ${CYAN}$iterations${NC}"
  echo -e "â•‘ Quality:    ${CYAN}$QUALITY_TIER${NC}"
  [[ "$DRY_RUN" == true ]] && echo -e "â•‘ Mode:       ${YELLOW}DRY RUN${NC}"
  [[ "$VERBOSE" == true ]] && echo -e "â•‘ Output:     ${CYAN}STREAMING${NC}"
  echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo ""

  if [[ "$DRY_RUN" == true ]]; then
    cmd_status
    echo -e "Would run ${CYAN}$iterations${NC} iterations."
    exit 0
  fi

  log_activity "Starting run: $iterations iterations (quality: $QUALITY_TIER)"

  local QUALITY
  QUALITY=$(get_quality_instructions)

  for ((i=1; i<=iterations; i++)); do
    # Deterministic spec selection (core decides, not Claude)
    local NEXT_SPEC
    NEXT_SPEC=$(get_next_spec)

    if [[ -z "$NEXT_SPEC" ]]; then
      echo "No incomplete unblocked specs found."
      show_summary
      exit 0
    fi

    local NEXT_SPEC_NAME
    NEXT_SPEC_NAME=$(basename "$NEXT_SPEC" .md)

    # Build context: selected spec fully, others as compact status (saves tokens)
    local CONTEXT="## SELECTED SPEC (implement this one)
@${NEXT_SPEC}

## Other Specs (status only)
"
    for spec in "$SPECS_DIR"/*.md; do
      [[ -f "$spec" ]] || continue
      [[ "$(basename "$spec")" == _* ]] && continue
      [[ "$spec" == "$NEXT_SPEC" ]] && continue  # Skip selected (already included)
      local sname spasses
      sname=$(basename "$spec" .md)
      spasses=$(extract_field "$spec" "passes")
      if [[ "$spasses" == "true" ]]; then
        CONTEXT="$CONTEXT
- $sname: âœ“ done"
      else
        CONTEXT="$CONTEXT
- $sname: pending"
      fi
    done
    [[ -f "$DONE_FILE" ]] && echo "All specs complete!" && rm -f "$DONE_FILE" && show_summary && exit 0

    local ROLE="Worker" ROLE_INST=""
    if [[ $((i % REVIEW_EVERY)) -eq 0 ]]; then
      ROLE="Reviewer"
      ROLE_INST="
## REVIEWER MODE
Before implementing, REVIEW:
1. Check progress.txt - are we on track?
2. Verify completed specs work: ${TEST_CMD}
3. Fix issues before continuing.
4. If stuck 2+ iterations, try different approach."
    fi

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Iteration $i/$iterations [$ROLE]"
    echo -e "Spec: ${CYAN}$NEXT_SPEC_NAME${NC}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    log_activity "Iteration $i/$iterations started: $NEXT_SPEC_NAME [$ROLE]"

    local HASH
    HASH=$(get_state_hash)
    if [[ "$HASH" == "$LAST_HASH" ]] && [[ -n "$LAST_HASH" ]]; then
      ((STUCK++))
      [[ $STUCK -ge 2 ]] && echo -e "${YELLOW}âš  Stuck for $STUCK iterations${NC}"
    else
      STUCK=0
      LAST_HASH="$HASH"
    fi

    echo "Iteration $i - $(date '+%Y-%m-%d %H:%M:%S') [$ROLE] Spec: $NEXT_SPEC_NAME" >> "$LOG_FILE"

    local STUCK_WARN=""
    [[ $STUCK -ge 2 ]] && STUCK_WARN="
## âš  STUCK DETECTION
No progress for $STUCK iterations. Try DIFFERENT approach:
- Add debugging to understand the issue
- Read errors carefully, fix root cause
- Consider if approach is fundamentally wrong"

    local LEARNINGS=""
    [[ -f "$LEARNINGS_FILE" ]] && LEARNINGS="@${LEARNINGS_FILE}"

    # Dynamic configuration prepended to prompt
    local CONFIG="## Configuration
- Build: ${BUILD_CMD}
- Test: ${TEST_CMD}
- Lint: ${LINT_CMD}
- Session: ${SESSION_ID}
- Done file: ${DONE_FILE}

$QUALITY
$ROLE_INST
$STUCK_WARN
"

    local PROMPT="$CONFIG

$CONTEXT @${PROGRESS_FILE} $LEARNINGS @${PROMPT_FILE}"

    run_claude "$PROMPT" "$LOG_FILE" "$VERBOSE"
    local claude_exit=$?

    # Handle non-zero exit (including timeout 124)
    if [[ $claude_exit -ne 0 ]]; then
      # Check if spec was completed despite exit code
      if spec_passes "$NEXT_SPEC"; then
        echo -e "${YELLOW}âš ${NC} Claude exited ($claude_exit) but spec completed successfully"
        log_activity "$NEXT_SPEC_NAME completed (despite exit $claude_exit)"
      else
        echo -e "${RED}âœ—${NC} Claude failed (exit $claude_exit)"
        log_activity "ERROR: $NEXT_SPEC_NAME failed (exit $claude_exit) - Iteration $i"
        show_summary
        exit 1
      fi
    fi

    COMPLETED=$i

    # Redundant completion check: all three signals must agree
    local all_specs_pass=true
    for spec in "$SPECS_DIR"/*.md; do
      [[ -f "$spec" ]] || continue
      [[ "$(basename "$spec")" == _* ]] && continue
      if ! spec_passes "$spec"; then
        all_specs_pass=false
        break
      fi
    done

    local has_done_file=false
    [[ -f "$DONE_FILE" ]] && has_done_file=true

    local has_complete_token=false
    [[ "$CLAUDE_RESULT" == *"<promise>COMPLETE</promise>"* ]] && has_complete_token=true

    # All three conditions must be true for completion
    if [[ "$all_specs_pass" == "true" ]] && \
       [[ "$has_done_file" == "true" ]] && \
       [[ "$has_complete_token" == "true" ]]; then
      echo -e "${GREEN}All specs complete!${NC} (verified: file + token + all passes)"
      log_activity "All specs complete after $i iterations"
      rm -f "$DONE_FILE"
      show_summary
      exit 0
    fi

    # Warn if signals disagree (helps debug false completion attempts)
    if [[ "$has_done_file" == "true" ]] && [[ "$all_specs_pass" != "true" ]]; then
      echo -e "${YELLOW}WARNING:${NC} .baldrick-done exists but not all specs pass - cleaning up"
      rm -f "$DONE_FILE"
    fi

    if [[ "$has_complete_token" == "true" ]] && [[ "$all_specs_pass" != "true" ]]; then
      echo -e "${YELLOW}WARNING:${NC} COMPLETE token received but not all specs pass - continuing"
    fi

    # Write per-iteration JSON artifact for observability
    local iter_file="$LOG_DIR/iter-$(printf '%04d' $i).json"
    cat > "$iter_file" << EOF
{
  "iteration": $i,
  "timestamp": "$(date -Iseconds 2>/dev/null || date '+%Y-%m-%dT%H:%M:%S')",
  "selected_spec": "$NEXT_SPEC_NAME",
  "state_hash": "$HASH",
  "mode": "$ROLE",
  "stuck_count": $STUCK,
  "completion_signals": {
    "done_file": $has_done_file,
    "complete_token": $has_complete_token,
    "all_specs_pass": $all_specs_pass
  }
}
EOF

    echo ""
  done

  echo "Completed $iterations iterations"
  log_activity "Completed $iterations iterations"
  rm -f "$DONE_FILE"
  show_summary
}

# =============================================================================
# COMMAND: once (single spec focus)
# =============================================================================

cmd_once() {
  local spec_name="" max_iterations=30 VERBOSE=false

  while [[ $# -gt 0 ]]; do
    case $1 in
      --max) max_iterations="$2"; shift 2 ;;
      --verbose|-v) VERBOSE=true; shift ;;
      -h|--help) echo "Usage: baldrick once <spec-name> [--max n] [--verbose|-v]"; exit 0 ;;
      *) [[ -z "$spec_name" ]] && spec_name="$1"; shift ;;
    esac
  done

  [[ -z "$spec_name" ]] && echo "Error: spec name required" && exit 1

  local spec_file="$SPECS_DIR/${spec_name}.md"
  [[ "$spec_name" == *.md ]] && spec_file="$SPECS_DIR/$spec_name" && spec_name="${spec_name%.md}"

  [[ ! -f "$spec_file" ]] && echo "Not found: $spec_file" && exit 1

  check_session_change
  generate_session_id

  local LOG_FILE="$LOG_DIR/baldrick-once-${spec_name}-$(date '+%Y%m%d-%H%M%S').log"
  local DONE_FILE=".baldrick-done-${spec_name}"
  local PROMPT_FILE="/tmp/baldrick-prompt-$$.md"
  mkdir -p "$LOG_DIR"
  rm -f "$DONE_FILE"

  # Write embedded prompt to temp file (cleaned up on exit)
  echo "$EMBEDDED_PROMPT" > "$PROMPT_FILE"
  trap "rm -f '$PROMPT_FILE'" EXIT

  local START_TIME COMPLETED=0 LAST_HASH="" STUCK=0
  START_TIME=$(date +%s)

  get_spec_hash() { md5sum "$spec_file" 2>/dev/null | cut -d' ' -f1 || md5 -q "$spec_file" 2>/dev/null; }

  echo ""
  echo -e "${BOLD}baldrick once: $spec_name${NC}"
  echo -e "Max iterations: ${CYAN}$max_iterations${NC}"
  [[ "$VERBOSE" == true ]] && echo -e "Output:         ${CYAN}STREAMING${NC}"
  echo ""

  trap 'stop_spinner; echo "Interrupted after $COMPLETED iterations"; log_activity "Interrupted $spec_name after $COMPLETED iterations"; rm -f "$DONE_FILE"; exit 130' INT

  log_activity "Starting focused work on $spec_name (max: $max_iterations iterations)"

  local LEARNINGS=""
  [[ -f "$LEARNINGS_FILE" ]] && LEARNINGS="@${LEARNINGS_FILE}"
  local QUALITY
  QUALITY=$(get_quality_instructions)

  for ((i=1; i<=max_iterations; i++)); do
    [[ -f "$DONE_FILE" ]] && echo -e "${GREEN}Complete: $spec_name${NC}" && rm -f "$DONE_FILE" && exit 0

    local ROLE="Worker" ROLE_INST=""
    if [[ $((i % REVIEW_EVERY)) -eq 0 ]]; then
      ROLE="Reviewer"
      ROLE_INST="
## REVIEWER MODE
Before continuing, REVIEW:
1. Does current implementation match the spec?
2. Run tests: ${TEST_CMD}
3. Fix issues before moving on."
    fi

    echo "[$spec_name] Iteration $i/$max_iterations [$ROLE]"
    log_activity "[$spec_name] Iteration $i started [$ROLE]"

    local HASH
    HASH=$(get_spec_hash)
    if [[ "$HASH" == "$LAST_HASH" ]] && [[ -n "$LAST_HASH" ]]; then
      ((STUCK++))
      [[ $STUCK -ge 2 ]] && echo -e "${YELLOW}âš  Stuck for $STUCK iterations${NC}"
    else
      STUCK=0
      LAST_HASH="$HASH"
    fi

    local STUCK_WARN=""
    [[ $STUCK -ge 2 ]] && STUCK_WARN="
## âš  STUCK
No progress for $STUCK iterations. Try DIFFERENT approach or output <promise>BLOCKED</promise> if truly stuck."

    # Dynamic configuration prepended to prompt
    local CONFIG="## Configuration
- Build: ${BUILD_CMD}
- Test: ${TEST_CMD}
- Lint: ${LINT_CMD}
- Session: ${SESSION_ID}
- Done file: ${DONE_FILE}

$QUALITY
$ROLE_INST
$STUCK_WARN

## Focus Mode
Work ONLY on this spec: $spec_name
(Ignore priority selection - focus on this single spec)
"

    local PROMPT="$CONFIG

@${spec_file} @${PROGRESS_FILE} $LEARNINGS @${PROMPT_FILE}"

    run_claude "$PROMPT" "$LOG_FILE" "$VERBOSE"
    local claude_exit=$?

    # Handle non-zero exit (including timeout 124)
    if [[ $claude_exit -ne 0 ]]; then
      if spec_passes "$spec_file"; then
        echo -e "${YELLOW}âš ${NC} Claude exited ($claude_exit) but spec completed successfully"
        log_activity "$spec_name completed (despite exit $claude_exit)"
      else
        echo -e "${RED}âœ—${NC} Claude failed (exit $claude_exit)"
        log_activity "ERROR: $spec_name failed (exit $claude_exit) - Iteration $i"
        exit 1
      fi
    fi

    COMPLETED=$i

    if [[ -f "$DONE_FILE" ]] || [[ "$CLAUDE_RESULT" == *"<promise>COMPLETE</promise>"* ]]; then
      echo -e "${GREEN}Complete: $spec_name${NC}"
      log_activity "$spec_name completed after $i iterations"
      rm -f "$DONE_FILE"
      exit 0
    fi

    if [[ "$CLAUDE_RESULT" == *"<promise>BLOCKED</promise>"* ]]; then
      echo -e "${RED}Blocked: $spec_name${NC} - check progress.txt"
      rm -f "$DONE_FILE"
      exit 1
    fi
  done

  echo -e "${YELLOW}Max iterations reached for $spec_name${NC}"
  rm -f "$DONE_FILE"
  exit 1
}

# =============================================================================
# COMMAND: archive
# =============================================================================

cmd_archive() {
  case "${1:-}" in
    list)
      echo ""
      echo -e "${BOLD}Archived Sessions${NC}"
      echo ""
      if [[ ! -d "$ARCHIVE_DIR" ]] || [[ -z "$(ls -A "$ARCHIVE_DIR" 2>/dev/null)" ]]; then
        echo "No archives found."
        exit 0
      fi
      for archive in "$ARCHIVE_DIR"/*/; do
        [[ -d "$archive" ]] || continue
        local name specs
        name=$(basename "$archive")
        specs=0
        [[ -d "$archive/specs" ]] && specs=$(ls -1 "$archive/specs"/*.md 2>/dev/null | wc -l | tr -d ' ')
        echo -e "  ${CYAN}$name${NC} ($specs specs)"
      done
      ;;
    restore)
      local name="$2"
      [[ -z "$name" ]] && echo "Usage: baldrick archive restore <name>" && exit 1
      local path="$ARCHIVE_DIR/$name"
      [[ ! -d "$path" ]] && echo "Not found: $name" && exit 1

      echo "Restoring: $name"
      [[ -d "$path/specs" ]] && mkdir -p "$SPECS_DIR" && cp "$path/specs"/*.md "$SPECS_DIR/" 2>/dev/null
      [[ -f "$path/progress.txt" ]] && cp "$path/progress.txt" "$PROGRESS_FILE"
      [[ -f "$path/baldrick-learnings.md" ]] && cp "$path/baldrick-learnings.md" "$LEARNINGS_FILE"
      echo "restored/$name" > "$LAST_SESSION_FILE"
      echo -e "${GREEN}Restored.${NC}"
      ;;
    -h|--help)
      echo "Usage: baldrick archive [list|restore <name>]"
      ;;
    "")
      local current
      current=$(get_current_session)
      [[ -z "$current" ]] && echo "No session to archive." && exit 1
      archive_session "$current"
      rm -f "$LAST_SESSION_FILE"
      echo -e "${GREEN}Archived.${NC}"
      ;;
    *)
      echo "Unknown: $1"
      exit 1
      ;;
  esac
}

# =============================================================================
# COMMAND: init (from blackadder)
# =============================================================================

cmd_init() {
  echo -e "${BOLD}baldrick init${NC}"
  echo ""

  mkdir -p "$SPECS_DIR" "$DOCS_DIR" "$TEMPLATES_DIR"
  echo -e "${GREEN}âœ“${NC} Created: specs/, docs/, templates/"

  if [[ ! -f "$PROGRESS_FILE" ]]; then
    cat > "$PROGRESS_FILE" <<'EOF'
# Baldrick Progress Log

## Codebase Patterns
<!-- Add reusable patterns here as you discover them -->

## Key Files
<!-- Add critical files here -->

---

<!-- Claude appends progress notes below this line -->
EOF
    echo -e "${GREEN}âœ“${NC} Created: progress.txt"
  fi

  if [[ ! -f "$LEARNINGS_FILE" ]]; then
    cat > "$LEARNINGS_FILE" <<'EOF'
# Baldrick Learnings

Permanent patterns and knowledge about this codebase.
Update this when you discover something reusable across specs.

## Codebase Patterns

<!-- Add patterns here, e.g.: -->
<!-- - Error handling: use CustomError class from src/errors.ts -->
<!-- - API responses: always wrap in { data, error } shape -->

## Key Files

<!-- Add critical files here, e.g.: -->
<!-- - src/db/schema.ts - database schema -->

## Gotchas

<!-- Add project-specific gotchas, e.g.: -->
<!-- - Must run db:generate after schema changes -->
EOF
    echo -e "${GREEN}âœ“${NC} Created: baldrick-learnings.md"
  fi

  # Create simple template
  if [[ ! -f "$TEMPLATES_DIR/feature.md" ]]; then
    cat > "$TEMPLATES_DIR/feature.md" <<'EOF'
---
id: [feature-name-v1]   # Unique identifier (kebab-case)
title: "[FEATURE_TITLE]"
passes: false
priority: medium        # high | medium | low
risk: standard          # spike | integration | standard | polish
created: [DATE]
depends_on: []          # Array of spec ids (optional)
---

# [FEATURE_TITLE]

> **One-liner:** [What this does in 10 words or less]

## Context

**User:** [Who uses this?]
**Trigger:** [What kicks this off?]
**Success:** [What does "working" look like?]

## Scope

**In:** [What we're building]
**Out:** [What we're NOT building]

## Examples

| Input | Expected Output |
|-------|-----------------|
| `[real example input]` | `[real example output]` |
| `[edge case input]` | `[edge case handling]` |

## Scenarios

### Scenario: [Happy path]
```gherkin
Given [concrete precondition]
When [specific action]
Then [explicit result]
```

### Scenario Outline: [Validation cases]
```gherkin
Given [precondition]
When [action with <input>]
Then [expected <output>]

Examples:
  | input           | output              |
  | valid_value     | success response    |
  | invalid_value   | error message       |
```

## Done When

- [ ] [Specific criterion 1]
- [ ] [Specific criterion 2]
- [ ] Build passes
- [ ] Tests pass
EOF
    echo -e "${GREEN}âœ“${NC} Created: templates/feature.md"
  fi

  # Create detailed template
  if [[ ! -f "$TEMPLATES_DIR/feature-detailed.md" ]]; then
    cat > "$TEMPLATES_DIR/feature-detailed.md" <<'EOF'
---
id: [feature-name-v1]   # Unique identifier (kebab-case)
title: "[FEATURE_TITLE]"
passes: false
priority: medium        # high | medium | low
risk: standard          # spike | integration | standard | polish
created: [DATE]
depends_on: []          # Array of spec ids (optional)
---

# [FEATURE_TITLE]

> **One-liner:** [What this does in 10 words or less]

## Context

| | |
|---|---|
| **User** | [Who uses this?] |
| **Trigger** | [What kicks this off?] |
| **Success** | [What does "working" look like?] |

## Scope

**In Scope:**
- [Specific deliverable 1]
- [Specific deliverable 2]

**Out of Scope:**
- [Thing we're NOT building]
- [Future consideration]

## Dependencies

- [ ] [Prerequisite that must exist first]
- [ ] [External API/service this needs]

## Flow

```mermaid
flowchart TD
    A[Start] --> B{Validate}
    B -->|Valid| C[Process]
    B -->|Invalid| D[Return Error]
    C --> E[Success Response]
```

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Input  â”‚â”€â”€â”€â”€â–¶â”‚ Validate â”‚â”€â”€â”€â”€â–¶â”‚ Process â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼ (invalid)
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  Error  â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Examples

### Happy Path
| Input | Action | Output |
|-------|--------|--------|
| `alice@example.com, secret123` | Login | `{token: "abc...", user: {id: 1}}` |

### Edge Cases
| Input | Condition | Expected |
|-------|-----------|----------|
| `""` | Empty email | `400: {error: "Email required"}` |
| `not-an-email` | Invalid format | `400: {error: "Invalid email"}` |

### Error Responses
| Trigger | Code | Response |
|---------|------|----------|
| Invalid credentials | 401 | `{error: "Invalid credentials"}` |
| Server error | 500 | `{error: "Internal server error"}` |

## Scenarios

### Scenario: [Happy path name]
```gherkin
Given [concrete precondition with real values]
When [specific action with real data]
Then [explicit expected result]
And [additional assertion]
```

### Scenario Outline: [Validation cases]
```gherkin
Given [precondition]
When [action with <input>]
Then I receive <status> with <response>

Examples:
  | input              | status | response                |
  | valid_data         | 200    | success object          |
  | missing_field      | 400    | "Field required"        |
  | invalid_format     | 400    | "Invalid format"        |
```

### Scenario: [Error case name]
```gherkin
Given [precondition]
When [action that triggers error]
Then [specific error response]
And [side effects - e.g., "no data is modified"]
```

## Files

```
src/
â”œâ”€â”€ [path]/
â”‚   â””â”€â”€ [file.ts]        # [What this file does]
â””â”€â”€ tests/
    â””â”€â”€ [file.test.ts]   # Tests for this feature
```

## Done When

- [ ] [Specific, testable criterion 1]
- [ ] [Specific, testable criterion 2]
- [ ] [Error case is handled correctly]
- [ ] Build passes
- [ ] Tests pass with new tests
- [ ] Manual: [Specific verification step]
EOF
    echo -e "${GREEN}âœ“${NC} Created: templates/feature-detailed.md"
  fi

  echo ""
  echo -e "${GREEN}Done!${NC}"
  echo ""
  echo "Next steps:"
  echo "  1. Create a spec in specs/ (see templates/ for examples)"
  echo "  2. baldrick validate"
  echo "  3. baldrick run 10"
}

# =============================================================================
# COMMAND: validate (from blackadder)
# =============================================================================

cmd_validate() {
  local quiet=false
  while [[ $# -gt 0 ]]; do
    case $1 in
      --quiet|-q) quiet=true; shift ;;
      *) shift ;;
    esac
  done

  [[ "$quiet" != true ]] && echo "" && echo -e "${BOLD}Validating specs${NC}" && echo ""

  if [[ ! -d "$SPECS_DIR" ]] || [[ -z "$(ls -A "$SPECS_DIR"/*.md 2>/dev/null)" ]]; then
    [[ "$quiet" != true ]] && echo "No specs found in $SPECS_DIR"
    return 0
  fi

  local total=0 errors=0 warnings=0

  for spec in "$SPECS_DIR"/*.md; do
    [[ -f "$spec" ]] || continue
    [[ "$(basename "$spec")" == _* ]] && continue
    ((total++))

    local name spec_errors spec_warnings
    name=$(basename "$spec" .md)
    spec_errors=0
    spec_warnings=0

    # Check frontmatter exists
    if ! head -1 "$spec" | grep -q '^---$'; then
      [[ "$quiet" != true ]] && echo -e "  ${RED}âœ—${NC} $name: Missing YAML frontmatter"
      ((spec_errors++))
    fi

    # Extract all fields
    local title passes priority risk created
    title=$(extract_field "$spec" "title")
    passes=$(extract_field "$spec" "passes")
    priority=$(extract_field "$spec" "priority")
    risk=$(extract_field "$spec" "risk")
    created=$(extract_field "$spec" "created")

    # Required: title (non-empty)
    if [[ -z "$title" ]]; then
      [[ "$quiet" != true ]] && echo -e "  ${RED}âœ—${NC} $name: Missing 'title'"
      ((spec_errors++))
    fi

    # Required: passes (boolean)
    if [[ -z "$passes" ]]; then
      [[ "$quiet" != true ]] && echo -e "  ${RED}âœ—${NC} $name: Missing 'passes'"
      ((spec_errors++))
    elif [[ "$passes" != "true" ]] && [[ "$passes" != "false" ]]; then
      [[ "$quiet" != true ]] && echo -e "  ${RED}âœ—${NC} $name: 'passes' must be true or false (got: $passes)"
      ((spec_errors++))
    fi

    # Enum: priority (high | medium | low)
    if [[ -n "$priority" ]] && [[ ! "$priority" =~ ^(high|medium|low)$ ]]; then
      [[ "$quiet" != true ]] && echo -e "  ${RED}âœ—${NC} $name: 'priority' must be: high | medium | low (got: $priority)"
      ((spec_errors++))
    fi

    # Enum: risk (spike | integration | standard | polish)
    if [[ -n "$risk" ]] && [[ ! "$risk" =~ ^(spike|integration|standard|polish)$ ]]; then
      [[ "$quiet" != true ]] && echo -e "  ${RED}âœ—${NC} $name: 'risk' must be: spike | integration | standard | polish (got: $risk)"
      ((spec_errors++))
    fi

    # Optional but validated: created (YYYY-MM-DD format)
    if [[ -n "$created" ]] && [[ ! "$created" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
      [[ "$quiet" != true ]] && echo -e "  ${YELLOW}âš ${NC} $name: 'created' should be YYYY-MM-DD format (got: $created)"
      ((spec_warnings++))
    fi

    # Validate depends_on references exist
    local depends_on
    depends_on=$(extract_field "$spec" "depends_on")
    if [[ -n "$depends_on" ]]; then
      # Clean YAML array syntax
      depends_on="${depends_on#[}"
      depends_on="${depends_on%]}"
      depends_on="${depends_on//\"/}"
      depends_on="${depends_on//\'/}"

      local dep_id
      for dep_id in ${depends_on//,/ }; do
        dep_id="${dep_id// /}"
        [[ -z "$dep_id" ]] && continue

        if ! find_spec_by_id "$dep_id" >/dev/null 2>&1; then
          [[ "$quiet" != true ]] && echo -e "  ${RED}âœ—${NC} $name: depends_on references unknown ID '$dep_id'"
          ((spec_errors++))
        fi
      done
    fi

    if [[ $spec_errors -eq 0 ]]; then
      if [[ "$quiet" != true ]]; then
        if [[ $spec_warnings -gt 0 ]]; then
          echo -e "  ${YELLOW}âš ${NC} $name (with warnings)"
        else
          echo -e "  ${GREEN}âœ“${NC} $name"
        fi
      fi
    else
      ((errors++))
    fi
    ((warnings += spec_warnings))
  done

  [[ "$quiet" != true ]] && echo ""
  if [[ $errors -eq 0 ]]; then
    if [[ "$quiet" != true ]]; then
      if [[ $warnings -gt 0 ]]; then
        echo -e "${GREEN}All $total specs valid${NC} (${YELLOW}$warnings warning(s)${NC})"
      else
        echo -e "${GREEN}All $total specs valid${NC}"
      fi
    fi
    return 0
  else
    [[ "$quiet" != true ]] && echo -e "${RED}$errors of $total specs have errors${NC}"
    return 1
  fi
}


# =============================================================================
# COMMAND: doctor
# =============================================================================

cmd_doctor() {
  echo ""
  echo -e "${BOLD}baldrick doctor${NC} - Configuration Check"
  echo ""

  local errors=0 warnings=0

  # Check Claude CLI
  if command -v "$CLAUDE_RUNNER" >/dev/null 2>&1; then
    echo -e "${GREEN}âœ“${NC} Claude CLI found: $CLAUDE_RUNNER"
  else
    echo -e "${RED}âœ—${NC} Claude CLI not found: $CLAUDE_RUNNER"
    echo "  Install: https://docs.anthropic.com/claude-code"
    ((errors++))
  fi

  # Show detected project type
  echo -e "${GREEN}âœ“${NC} Project type: ${CYAN}$DETECTED_PROJECT_TYPE${NC}"

  # Check build/test/lint commands
  [[ -n "$BUILD_CMD" ]] && echo -e "${GREEN}âœ“${NC} BUILD_CMD: $BUILD_CMD" || { echo -e "${YELLOW}âš ${NC} BUILD_CMD not set"; ((warnings++)); }
  [[ -n "$TEST_CMD" ]] && echo -e "${GREEN}âœ“${NC} TEST_CMD: $TEST_CMD" || { echo -e "${YELLOW}âš ${NC} TEST_CMD not set"; ((warnings++)); }
  [[ -n "$LINT_CMD" ]] && echo -e "${GREEN}âœ“${NC} LINT_CMD: $LINT_CMD" || { echo -e "${YELLOW}âš ${NC} LINT_CMD not set"; ((warnings++)); }

  echo -e "${GREEN}âœ“${NC} QUALITY_TIER: $QUALITY_TIER"
  echo -e "${GREEN}âœ“${NC} REVIEW_EVERY: $REVIEW_EVERY"
  echo -e "${GREEN}âœ“${NC} CLAUDE_TIMEOUT: ${CLAUDE_TIMEOUT}s"

  if [[ -n "$NOTIFY_CMD" ]]; then
    echo -e "${GREEN}âœ“${NC} NOTIFY_CMD: ${NOTIFY_CMD:0:40}..."
  else
    echo -e "${DIM}â—‹${NC} NOTIFY_CMD not set (optional)"
  fi

  # Check directories
  if [[ -d "$SPECS_DIR" ]]; then
    local spec_count
    spec_count=$(ls -1 "$SPECS_DIR"/*.md 2>/dev/null | wc -l | tr -d ' ')
    echo -e "${GREEN}âœ“${NC} specs/ exists ($spec_count specs)"
  else
    echo -e "${YELLOW}âš ${NC} specs/ not found - run 'baldrick init'"
    ((warnings++))
  fi

  [[ -d "$LOG_DIR" ]] && echo -e "${GREEN}âœ“${NC} logs/ exists" || echo -e "${DIM}â—‹${NC} logs/ will be created on first run"
  [[ -f "$PROGRESS_FILE" ]] && echo -e "${GREEN}âœ“${NC} progress.txt exists" || { echo -e "${YELLOW}âš ${NC} progress.txt not found - run 'baldrick init'"; ((warnings++)); }
  [[ -f "$LEARNINGS_FILE" ]] && echo -e "${GREEN}âœ“${NC} baldrick-learnings.md exists" || echo -e "${DIM}â—‹${NC} baldrick-learnings.md will be created on init"

  # Check git
  if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo -e "${GREEN}âœ“${NC} Git repository detected"
  else
    echo -e "${YELLOW}âš ${NC} Not a git repository - commits won't work"
    ((warnings++))
  fi

  # Validate specs if they exist
  if [[ -d "$SPECS_DIR" ]] && [[ -n "$(ls -A "$SPECS_DIR"/*.md 2>/dev/null)" ]]; then
    echo ""
    echo -e "${BOLD}Spec Validation:${NC}"
    local spec_errors=0
    for spec in "$SPECS_DIR"/*.md; do
      [[ -f "$spec" ]] || continue
      [[ "$(basename "$spec")" == _* ]] && continue
      local name
      name=$(basename "$spec" .md)
      local title passes
      title=$(extract_field "$spec" "title")
      passes=$(extract_field "$spec" "passes")
      if [[ -n "$title" ]] && [[ -n "$passes" ]]; then
        echo -e "  ${GREEN}âœ“${NC} $name"
      else
        echo -e "  ${RED}âœ—${NC} $name - run 'baldrick validate' for details"
        ((spec_errors++))
      fi
    done
    [[ $spec_errors -gt 0 ]] && ((errors += spec_errors))
  fi

  # Summary
  echo ""
  if [[ $errors -eq 0 ]] && [[ $warnings -eq 0 ]]; then
    echo -e "${GREEN}All checks passed!${NC} Ready to run."
  elif [[ $errors -eq 0 ]]; then
    echo -e "${YELLOW}$warnings warning(s)${NC} - baldrick can run but may have issues"
  else
    echo -e "${RED}$errors error(s)${NC} - please fix before running"
    exit 1
  fi
}

# =============================================================================
# COMMAND: new (quick spec creation)
# =============================================================================

cmd_new() {
  local name="" title="" priority="medium" depends=""

  while [[ $# -gt 0 ]]; do
    case $1 in
      -h|--help)
        echo "Usage: baldrick new <spec-name> [--title \"Title\"] [--priority high|medium|low] [--depends id1,id2]"
        exit 0
        ;;
      --title) title="$2"; shift 2 ;;
      --priority) priority="$2"; shift 2 ;;
      --depends) depends="$2"; shift 2 ;;
      *) [[ -z "$name" ]] && name="$1"; shift ;;
    esac
  done

  [[ -z "$name" ]] && { echo "Usage: baldrick new <spec-name>"; exit 1; }

  # Clean name (remove .md if provided)
  name="${name%.md}"

  local spec_file="$SPECS_DIR/${name}.md"
  [[ -f "$spec_file" ]] && { echo -e "${RED}Spec already exists:${NC} $spec_file"; exit 1; }

  mkdir -p "$SPECS_DIR"

  # Generate defaults
  local id="${name}-v1"
  local created=$(date +%Y-%m-%d)
  [[ -z "$title" ]] && title="$name"

  # Validate priority
  if [[ ! "$priority" =~ ^(high|medium|low)$ ]]; then
    echo -e "${YELLOW}Invalid priority '$priority', using 'medium'${NC}"
    priority="medium"
  fi

  # Write spec file
  cat > "$spec_file" << EOF
---
id: $id
title: "$title"
passes: false
priority: $priority
created: $created
depends_on: [${depends}]
---

# $title

> **One-liner:** [Brief description of what this does]

## Context

**User:** [Who uses this?]
**Trigger:** [What kicks this off?]
**Success:** [What does "working" look like?]

## Scenarios

### Scenario: Happy path
\`\`\`gherkin
Given [precondition]
When [action]
Then [expected result]
\`\`\`

## Done When

- [ ] [Specific criterion 1]
- [ ] [Specific criterion 2]
- [ ] Build passes
- [ ] Tests pass
EOF

  echo -e "${GREEN}âœ“${NC} Created: $spec_file"
  echo ""
  echo "Edit the file to add details, then run: baldrick validate"
}

# =============================================================================
# COMMAND: logs (view/tail logs)
# =============================================================================

cmd_logs() {
  local action="${1:-show}"
  mkdir -p "$LOG_DIR"

  case "$action" in
    tail|-f)
      local latest
      latest=$(ls -t "$LOG_DIR"/baldrick-*.log 2>/dev/null | head -1)
      [[ -z "$latest" ]] && { echo "No logs found in $LOG_DIR"; exit 1; }
      echo -e "${DIM}Tailing: $latest${NC}"
      echo -e "${DIM}Press Ctrl+C to stop${NC}"
      echo ""
      tail -f "$latest"
      ;;
    show|"")
      local latest
      latest=$(ls -t "$LOG_DIR"/baldrick-*.log 2>/dev/null | head -1)
      [[ -z "$latest" ]] && { echo "No logs found in $LOG_DIR"; exit 1; }
      echo -e "${BOLD}=== $(basename "$latest") ===${NC}"
      cat "$latest"
      ;;
    list|ls)
      echo -e "${BOLD}Logs in $LOG_DIR:${NC}"
      ls -lh "$LOG_DIR"/*.log 2>/dev/null || echo "No logs found"
      ;;
    activity|audit)
      if [[ ! -f "$ACTIVITY_LOG" ]]; then
        echo "No activity log yet. Run 'baldrick run' to generate activity."
        exit 0
      fi
      echo -e "${BOLD}=== Activity Log ===${NC}"
      if [[ "$2" == "tail" ]] || [[ "$2" == "-f" ]]; then
        tail -f "$ACTIVITY_LOG"
      else
        cat "$ACTIVITY_LOG"
      fi
      ;;
    clean|clear)
      local count
      count=$(ls -1 "$LOG_DIR"/*.log 2>/dev/null | wc -l | tr -d ' ')
      rm -f "$LOG_DIR"/*.log "$LOG_DIR"/iter-*.json 2>/dev/null
      echo -e "${GREEN}âœ“${NC} Cleaned $count log file(s)"
      ;;
    -h|--help|help)
      echo "Usage: baldrick logs [show|tail|list|activity|clean]"
      echo ""
      echo "Commands:"
      echo "  show      Show latest Claude output log (default)"
      echo "  tail      Follow latest log in real-time"
      echo "  list      List all log files"
      echo "  activity  Show activity audit trail"
      echo "  clean     Remove all log files"
      ;;
    *)
      echo "Unknown: $action"
      echo "Usage: baldrick logs [show|tail|list|activity|clean]"
      exit 1
      ;;
  esac
}

# =============================================================================
# COMMAND: skip/unskip (temporarily block specs)
# =============================================================================

cmd_skip() {
  local name="$1"
  [[ -z "$name" ]] && { echo "Usage: baldrick skip <spec-name>"; exit 1; }

  # Clean name
  name="${name%.md}"
  local spec_file="$SPECS_DIR/${name}.md"
  [[ ! -f "$spec_file" ]] && { echo -e "${RED}Not found:${NC} $spec_file"; exit 1; }

  # Check if already has blocked_by
  if grep -q "^blocked_by:" "$spec_file"; then
    sed -i '' 's/^blocked_by:.*/blocked_by: manual/' "$spec_file"
  else
    # Insert blocked_by after passes line
    sed -i '' '/^passes:/a\
blocked_by: manual
' "$spec_file"
  fi

  echo -e "${YELLOW}â­${NC} Skipped: $name"
  echo "  Spec will be excluded from selection until unskipped"
}

cmd_unskip() {
  local name="$1"
  [[ -z "$name" ]] && { echo "Usage: baldrick unskip <spec-name>"; exit 1; }

  # Clean name
  name="${name%.md}"
  local spec_file="$SPECS_DIR/${name}.md"
  [[ ! -f "$spec_file" ]] && { echo -e "${RED}Not found:${NC} $spec_file"; exit 1; }

  # Remove blocked_by line
  if grep -q "^blocked_by:" "$spec_file"; then
    sed -i '' '/^blocked_by:/d' "$spec_file"
    echo -e "${GREEN}âœ“${NC} Unskipped: $name"
  else
    echo "$name is not currently skipped"
  fi
}

# =============================================================================
# MAIN DISPATCHER
# =============================================================================

main() {
  local cmd="${1:-help}"
  shift 2>/dev/null || true

  case "$cmd" in
    # Execution
    run|r)         cmd_run "$@" ;;
    once)          cmd_once "$@" ;;

    # Status
    status|s|list) cmd_status ;;
    validate|v)    cmd_validate ;;

    # Utilities
    init)          cmd_init ;;
    archive)       cmd_archive "$@" ;;
    doctor)        cmd_doctor ;;
    new|n)         cmd_new "$@" ;;
    logs|l)        cmd_logs "$@" ;;
    skip)          cmd_skip "$@" ;;
    unskip)        cmd_unskip "$@" ;;

    # Meta
    help|-h|--help) cmd_help ;;
    --version|-V)   echo "baldrick v$VERSION" ;;

    # Unknown
    *)
      echo -e "${RED}Unknown:${NC} $cmd"
      echo ""
      cmd_help
      exit 1
      ;;
  esac
}

# =============================================================================
# MAIN GUARD - allows sourcing for testing
# =============================================================================

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  detect_project_type
  main "$@"
fi
